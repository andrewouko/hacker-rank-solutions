<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <div class='parent'>Div 01
        <div class='child'>Div 02</div>
    </div>
    <style>
        .parent {
            background-color: red;
            height: 50px;
            display: flex;
            align-items: center;
        }

        .child {
            background-color: blue;
            width: 30%
        }
    </style>
    <script>
        function fizzBuzz(n) {
            // Write your code here
            for (let i = 1; i <= n; i++) {
                if (i % 3 == 0 && i % 5 == 0) console.log('FizzBuzz');
                else if (i % 3 == 0) console.log('Fizz');
                else if (i % 5 == 0) console.log('Buzz');
                else console.log(i)
            }
        }

        // fizzBuzz(15)

        // m from the back
        function mFromBack(l, m) {
            let reverse = []
            let r_index = 0
            let start = (l.length - 1)
            while (start > -1) {
                reverse[r_index] = l[start]
                start--
                r_index++
            }
            // console.log(reverse)
            for (let i = 1; i <= l.length; i++) {
                if (i == m) return console.log(reverse[(i - 1)])
            }
            console.log('NIL')
        }
        mFromBack([10, 200, 3, 40000, 5], 4)
        mFromBack([42], 2)


        function factorial(n) {
            // assume n is only positive integers and 0

            // recursive step (for n>= 1 n = the product of n and the previous solution to the factorial)
            if (n >= 1) return n * factorial(n - 1)
            // base case (for n = 0)
            else return 1
        }
        // console.log(factorial(5))

        // get the fibonnaci number at position n
        function fibo(n) {
            // assume n is only integers

            // recursive step (for n>= 3 n = sum of two previous solutions to the fibo function)
            if (n >= 3) return fibo(n - 1) + fibo(n - 2)
            // base case (for n = 1 || n = 2)
            return 1
        }
        // console.log(fibo(5))


        // longest common prefix
        function getLongestCommonPrefix(strs) {
            first = strs[0]
            let prefix = ''
            // loop through all the letters in first string
            for (let i = 0; i < first.length; i++) {
                // current char in first string for comparison against the rest of the strings
                let current = first[i]

                // loop through all the other strings
                for (let j = 1; j < strs.length; j++) {
                    // compare current char in the first string against the current char in the current other string
                    // if there is a mismatch return the current state of the prefix string
                    if (current != strs[j][i]) return prefix
                }

                // if the loop hasn't broken (returned) then the current character is added to the prefix string
                // as it exists in all the string elements
                prefix += current
            }
        }

        // console.log(getLongestCommonPrefix( ["flower","flow","flight"]) )


        // num of ways of getting to the top if you can ascend one or 2 steps to the top
        // of a stairs with n length of steps

        // recursive algo solution
        function numWays(n) {
            // assume n is onl positive integers from 0

            // recursive step for n >= 2: n will be the sum of the previous 2 solutions to the function
            if (n >= 2) return numWays(n - 1) + numWays(n - 2)
            // base step for n = 0 || n = 1
            else return 1
        }

        // dyanmic programming solution
        function dpNumWays(n) {
            // assume n is onl positive integers from 0

            // return immediately for the base cases
            if (n == 1 || n == 0) return 1
            // for other cases
            else {
                // array to store the results
                let arr = []
                // since we already know the base case solutions
                arr[0] = 1; arr[1] = 1;
                // all other cases will be the sum of two previous solutions
                for (i = 2; i <= n; i++) {
                    arr[i] = arr[(i - 1)] + arr[(i - 2)]
                }
                return arr[n]
            }
        }

        // console.log(numWays(5))
        // console.log(dpNumWays(5))


        // console.log('drpoklj'.split('').sort().join(''))

        // Hacker rank grid challenge
        function gridChallenge(grid) {
            // use map to modify the grid such that;
            // each string in grid is sorted alphabetically
            grid = grid.map(string => {
                return string.split('').sort().join('')
            });
            console.log(grid)

            // get the first string in grid
            let first_string = grid[0];

            // loop through each char in first string
            for (let n = 0; n < first_string.length; n++) {
                // loop through each string in grid except the last one 
                // as it can't be compared with anything else
                for (let i = 0; i < grid.length - 1; i++) {
                    let current_string = grid[i];
                    let next_string = grid[i + 1]
                    // console.log(current_string, next_string)
                    // console.log(current_string[n], next_string[n])

                    // check if the current string's nth character is alaphabettically
                    // lower than the next string's nth character
                    // if it not return string NO to break out of the loop and function
                    if (!(current_string[n] < next_string[n])) return 'NO'
                }
            }
            // if the loop did not break/return then return string YES
            return 'YES'
        }

        // console.log(gridChallenge(['ebacd', 'fghij', 'olmkn', 'trpqs', 'xywuv']))


        // New Year's chaos
        function minimumBribes(queue) {
            // new array to store the queue in asc order
            // represents the original queue
            const qSorted = [...queue].sort()
            console.log('originaL', qSorted)
            console.log('current', queue)

            // bribe count
            let count = 0

            // loop through the original queue
            for (let i = 0; i < qSorted.length; i++) {

                // get the current position of person in queue
                let queue_index = queue.indexOf(qSorted[i])


                console.log('current', queue_index, 'original', i)
                // check if the current postion of person in queue is lower than the original position
                // if it is, update the bribe count
                if (queue_index < i) {
                    // update the number of positions moved forward to the current count
                    count += i - queue_index
                }

                // check if a person has bribed more than two people
                // that is, if the current position is more than two positions lower
                if (i - queue_index > 2) return 'Too chaotic'

            }
            return count
        }
        console.log(minimumBribes([2, 1, 5, 3, 4]))

        console.log(minimumBribes([2, 5, 1, 3, 4]))


        // fun with anagrams
        function funWithAnagrams(text) {
            // Write your code here
            let result = []

            // loop through all elements in array
            for (let i = 0; i < text.length; i++) {
                // console.log('i', i)
                // current element in array
                let current = text[i]
                console.log('current', current)

                // loop through all elements from current one
                for (let j = (i + 1); j < text.length; j++) {
                    // comparison element
                    let compare = text[j]
                    console.log('compare', compare)
                    console.log(current.split('').sort().join(''), compare.split('').sort().join(''))

                    // sort both current and compare if equal to see if they are anagrams
                    // console.log(j, current.split('').sort().join(''), compare.split('').sort().join(''))
                    // if equal they are anagrams
                    // remove current comparison element from text array
                    if (current.split('').sort().join('') == compare.split('').sort().join('')) {
                        text.splice(j, 1)

                        // console.log(text)
                        // result.push(current)
                    }
                    console.log(text)
                }
            }
            return text

        }

        console.log(funWithAnagrams(["code", "aaagmnrs", "anagrams", "doce"]))

        console.log(funWithAnagrams(["poke", "pkoe", "okpe", "ekop"]))

        function parkingDillema(cars, k) {
            cars = cars.sort((a, b) => a - b)
            // console.log(cars)
            let shortest = cars[cars.length - 1] - cars[0] + 1
            for (let i = 0; i < cars.length; i++) {
                if (cars[(i + k - 1)]) {
                    // distance between current element and next k - 1 cars
                    // console.log(cars[i], cars[i + k - 1],  cars[i + k - 1] - cars[i] + 1)
                    let distance = cars[i + k - 1] - cars[i] + 1
                    if (distance < shortest) shortest = distance
                }
            }
            return shortest
        }


        // console.log(parkingDillema([ 2, 10, 8, 17 ], 3))
        // console.log(parkingDillema([ 1, 2, 3, 10 ], 4))


        // search for target element in a sorted array
        function binarySearch(arr, target) {
            if (!arr || !arr.length) return 'No array'
            // left and right indices initialisation
            let left = 0;
            right = arr.length - 1


            // repeat the searching until the right and left indices cross(switch sides)
            // that is the right index is >= to the left index
            // if it is less than this shows we have searched the entire array and not found the target
            while (right >= left) {
                // get the midpoint index
                let mid = Math.floor((left + right) / 2)


                console.log('right', right, 'left', left, 'mid', mid)

                // if the value at the mid point is equal to the target 
                // return the mid point index
                if (arr[mid] == target) return mid

                // if the mid point value is > target
                // move the right pointer to the left
                // to search on the left side
                if (target < arr[mid]) right = mid - 1

                // if the mid point value is < target
                // move the left pointer to the right
                // to search on the right side

                if (target > arr[mid]) left = mid + 1

                console.log('right', right, 'left', left, 'mid', mid)
            }
            return -1
        }

        // shifted binary search
        function shiftedBinarySearch(arr, target) {
            if (!arr || !arr.length) return 'No array'

            // init the left and right indices
            let left = 0;
            let right = arr.length - 1

            // get the pivot index
            while (left < right) {
                // get the mid index
                let mid = Math.floor((left + right) / 2)

                // if the value at the mid > value at the right index
                // move the left pointer
                if (arr[mid] > arr[right]) left = mid + 1

                // otherwise if the value at the mid is <=
                // move the right pointer
                else right = mid - 1
            }


            // reset index and keep track of pivot index
            let start = left
            left = 0;
            right = arr.length - 1

            // determine the side of the rotated array to search from
            // make the search area the right side
            // if the target is within the pivot and index and the extreme right index
            if (target >= arr[start] && target <= arr[right]) left = start

            // make the search area to the left side
            // 

        }

        // console.log(shiftedBinarySearch([4,5,6,7,0,1,2], 0))

        // get the minimum integer not in the input array
        function solutionDemo(A) {
            // sort and filter positive integers
            const arr = A.sort((a, b) => a - b).filter(v => v >= 1)

            let x = 1
            for (let i = 0; i < arr.length; i++) {
                console.log(x, arr[i])
                // since x is less than return it
                if (x < arr[i])
                    return x
                else
                    // increment x to the next value
                    x = arr[i] + 1
            }

            return x

        }
        // console.log(solution( [1, 3, 6, 4, 1, 2]))
        // console.log(binarySearch([-2, 3, 4, 7, 8, 9, 11, 13], 11))


        // Given a string S with columns & rows get sum of column C
        function solution(S, C) {
            const arr = S.split('\n').map(col => col.split(','))
            // console.log(arr)
            const index = arr[0].indexOf(C)
            const c_arr = arr.map(v => v[index]).filter((v, i) => i > 0)
            // console.log(c_arr)
            const min = Math.min(...c_arr)
            // console.log(min)
            return min
        }
        solution("id,name,age,act.,room,dep.\n1,Jack,68,T,13,8\n17,Betty,28,F,15,7", "age")
        solution("area,land\n3722,CN\n6612,RU\n3855,CA\n3797,USA", "area")

        // Find a solution to ensure two consecutive elements do not add up to a negative number
        function solutionCount(A) {
            console.log(A)
            let sum = 0, count = 0
            for (let i = 0; i < A.length; i++) {
                /* let v = A[i]
                console.log('v',v, 'i', i)
                // check if postive hence a revenue
                sum += v
                console.log('sum', sum)
                if(sum < 0){
                    count++
                    A.splice(i, 1)
                    A.push(v)
                    i--
                    // console.log()
                    console.log(A, count)
                } */
                let curr = A[i]
                let next = A[i + 1]
                console.log('curr', curr, 'next', next)
                if (curr + next < 0) {
                    count++
                    A.splice(A.indexOf(curr), 1)
                    A.push(curr)
                    console.log(A, count)
                }

            }

            console.log(A, count)
            return count
        }
        // console.log(solutionCount([10, -10, -1, -1, 10]))
        // console.log(solutionCount([-1, -1, -1, 1, 1, 1, 1]))

        // Cleaning robot
        // ['.','.','.','X','.','.'],['']


        // number of substrings that have the same number of 1s and 0s
        function countBinarySubstrings(string) {
            /** 
             * Init vars
             * 
             * current tracks the number of similar characters we found in string
             * previous keeps track of the prevous number of similar characters we found
             * result is the number of valid substrings counted
            */
            let current = 0, previous = 0, result = 0
            for (let i = 1; i < string.length; i++) {
                // increment current if similar binary digit found
                if (string[i] == string[i - 1]) current++
                // if a different binary digit is found
                // set the previous to the current count of similar chars found
                // reset the current count to 1 as we starting to count a different type of digit
                else {
                    previous = current
                    current = 1
                }
                // as long as we have a a greater equal amount of the opposite char(stored in previous)
                // and current char we have a valid substring
                if (previous >= current) result++
            }
            return result
        }
        console.log(countBinarySubstrings('00001110011'))

        // check if a string is a palindrome
        function checkIfPalindrome(string) {
            // check if each of the characters in opposite side of the string  match
            for (let i = 0; i < string.length; i++) {
                if (string[i] == string[string.length - 1 - i]) continue
                else return false
            }
            return true
        }
        function checkIfPalindromeMiddleOut(string) {
            // get the midpoint of string
            const mid = (0 + string.length - 1) / 2
            // if string is of even length we will have two chars at middle
            let left = mid - 1, right = mid + 1
            if (string.length % 2 == 0) {
                left = Math.floor(mid)
                right = Math.floor(mid) + 1
            }

            console.log(mid, left, right)

            while (left >= 0 && right < string.length // if indices are within the string bounds
                && string[left] === string[right]) { // and the character match
                // expand out until the loop breaks
                left--
                right++
            }
            console.log(left, right)


        }

        function sum(numb) {
            if (numb == 1) return 1
            console.log(numb)
            return sum(numb - 1) + 1
        }
        console.log(sum(3))
        // console.log(checkIfPalindrome('ABBA'))
        // console.log(checkIfPalindrome('mierda'))
        // console.log(checkIfPalindromeMiddleOut('ABBA'))


        /** 
         * Convert to 24 hour time
        */
        function convertTime(string) {
            string = string.replace('AM', '')
            let time = string.split(':')
            let hours = parseInt(time[0], 10)

            hours += 12
            if (hours >= 24) hours -= 24

            time[0] = ('00' + hours).slice(-2)
            return time.join(':')
        }

        console.log(convertTime('12:01:00AM'))
        console.log(convertTime('07:05:45PM'))


        function median(arr) {
            const sorted_arr = arr.sort((a, b) => a - b)
            // console.log(sorted_arr)

            let mid = Math.floor(sorted_arr.length / 2)

            return sorted_arr[mid]
        }
        console.log(median(['5', '3', '1', '2', '4']))


        /**
         * 
         * Linked Lists */
        const SinglyLinkedListNode = class {
            constructor(nodeData) {
                this.data = nodeData;
                this.next = null;
            }
        };

        const SinglyLinkedList = class {
            constructor() {
                this.head = null;
                this.tail = null;
            }

            insertNode(nodeData) {
                const node = new SinglyLinkedListNode(nodeData);

                if (this.head == null) {
                    this.head = node;
                } else {
                    this.tail.next = node;
                }

                this.tail = node;
            }
        };




        // Complete the mergeLists function below.

        /*
         * For your reference:
         *
         * SinglyLinkedListNode {
         *     int data;
         *     SinglyLinkedListNode next;
         * }
         *
         */
        function mergeLists(head1, head2) {
            let head3 = new SinglyLinkedListNode(0)

            while (head1 || head2) {
                if (head1.data < head2.data) {
                    head3.next = head1
                }
                else {
                    head3.next = head2
                }
            }
            return head3
        }


        /** Min max sum function
         * 
         * Return the highest and the lowest sum 
         * 
         * of 4 numbers in any given 5 number array
         * 
         * */
        function minMaxSum(arr) {
            const min = Math.min(...arr)
            const max = Math.max(...arr)

            const sum = arr.reduce((a, b) => a + b)

            const max_sum = sum - min
            const min_sum = sum - max

            return `${min_sum} ${max_sum}`
        }

        console.log(minMaxSum([1, 3, 5, 7, 9]))


        /** 
         * Two sum
         * 
         * find the sum of two numbers in array that add up to the target
        */
        function twoSum(nums, target) {
            for (i = 0; i < nums.length; i++) {
                for (j = i + 1; j < nums.length; j++) {
                    // console.log(nums[i], nums[j], target)
                    if ((nums[i] + nums[j]) == target) return [i, j]
                }
            }
        }
        console.log(twoSum([1, 3, 5, 7, 9], 10))

        /** 
         * Two sum
         * 
         * find the sum of two numbers in array that add up to the target
         * 
         * using a hashmap to speed up the time complexity
        */
        function twoSumHashMap(nums, target) {
            let map = {}
            for (i = 0; i < nums.length; i++) {
                let complement_pair = target - nums[i]
                // console.log(nums[i], complement_pair, map)

                // add the current number to map
                // if the complement_pair does not exist
                if (!map[complement_pair])
                    map[nums[i]] = i
                // return the complement_pair key's value
                // and the current index
                else return [map[complement_pair], i]
            }
        }
        console.log(twoSumHashMap([1, 3, 5, 7, 9], 10))

        /** 
         * Find all duplicates in array
         * 
         * Numbers are between 1 and n
         * 
         * Solution 3 implementation (Refer to handwritten notes)
        */
        function findDuplicates(arr) {
            let result = []

            for (let i = 0; i < arr.length; i++) {
                let index = Math.abs(arr[i])

                // check if the nth element is negative
                // if negative we add it to the result set
                // e.g if the index is 4
                // we check if 4th element in arr is negative
                // if it is negative we add it to the result set
                // we mark the 4th element as negative
                if (arr[index - 1] < 0) result.push(Math.abs(arr[index - 1]))

                arr[index - 1] *= -1

            }

            return result
        }
        console.log(findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]))


        /** 
         * Get the tribonacci number at position n
         * Next element is determined by the sum of the preceding 3 elements
         * The signature contains the first 3 elements of the sequence
        */
        function tribonacci(signature, n) {
            if (n <= 0) return 0
            else if (n >= 4) return tribonacci(signature, n - 1) + tribonacci(signature, n - 2) + tribonacci(signature, n - 3)
            else return signature[n - 1]
        }
        console.log(tribonacci([0, 0, 1], 9))

        /** 
         * Print n tribonacci numbers
         * Next element is determined by the sum of the preceding 3 elements
         * The signature contains the first 3 elements of the sequence
        */
        function printTribonacci(signature, n) {
            let result = [...signature]
            for (let i = signature.length; i < n; i++) {
                let next = result[result.length - 1] + result[result.length - 2] + result[result.length - 3]
                result.push(next)
            }
            return result
        }
        console.log(printTribonacci([0, 0, 1], 9))



        /** 
         * Stack operations
         * Debug the code to ensure it works correctly
        */
        function stack(stackOperation, stackValue = null) {

            const stackHolder = {
                count: 4,
                storage: [
                    1,
                    '{id: 1,value: "obj"}',
                    "stringHolder",
                    46
                ]
            };
            const push = function (value) {
                stackHolder.storage[stackHolder.count] = value;
                stackHolder.count++
                return stackHolder.storage;
            }

            const pop = function () {
                if (stackHolder.count <= 0) {
                    return [];
                }

                const poppedItem = stackHolder.storage[stackHolder.count - 1];
                stackHolder.storage.splice(stackHolder.count - 1, 1)
                stackHolder.count--;
                return [poppedItem];
            }

            const peek = function () {
                return [stackHolder.storage[stackHolder.count - 1]];
            }

            const swap = function () {
                const top = stackHolder.count - 1
                const temp = stackHolder.storage[top]
                stackHolder.storage[top] = stackHolder.storage[top - 1]
                stackHolder.storage[top - 1] = temp
                return stackHolder.storage;
            }

            switch (stackOperation) {
                case 'push':
                    return push(stackValue);
                case 'pop':
                    return pop();
                case 'swap':
                    return swap();
                case 'peek':
                    return peek();
                default:
                    return stackHolder.storage;
            }
        }
        console.log(stack('push', 'new item'))
        console.log(stack('pop'))
        console.log(stack('peek'))
        console.log(stack('swap'))
        // console.log(stackHolder)


        /** 
         * Get the maximum value of two numbers
         * after +, -, * and / operations
        */
        function maxvalue(arr) {
            //Insert your code here 
            let max = 0

            // operations
            const operations = [
                arr.reduce((a, b) => a + b),
                arr.reduce((a, b) => a - b),
                arr.reduce((a, b) => a * b),
                arr.reduce((a, b) => a / b)
            ]

            console.log(operations)

            // check for math errors
            if (!operations.every(result => ![Infinity, -Infinity, NaN].includes(result))) return 'Undefined behavior'

            return Math.max(...operations)

        }

        console.log(maxvalue([5, 5]))

        /** 
         * 1 point for even
         * 3 points for odd
         * 5 points for each 5
        */
        function find_total(my_numbers) {
            // Insert your code here 

            let sum = 0

            // loop to test add add points
            for (let i = 0; i < my_numbers.length; i++) {
                if (my_numbers[i] % 2 === 0) sum += 1
                else if (my_numbers[i] === 5) sum += 5
                else sum += 3
            }

            return sum
        }
        console.log(find_total([1, 2, 3, 4, 5]))
        console.log(find_total([17, 19, 21]))
        console.log(find_total([5, 5, 5]))

        /** 
         * Get product of lowercase letters 
         * cnt1 --> number of vowels
         * cnt2 --> number of consonants with even numerical value
         * cnt3 --> number of consonants with odd numerical value
        */
        function productFromString(s_array) {
            //Insert your code here 
            let cnt1 = 0, cnt2 = 0, cnt3 = 0

            for (let i = 0; i < s_array.length; i++) {
                // check for vowels
                if (['a', 'e', 'i', 'o', 'u'].includes(s_array[i])) cnt1++
                // check the consonants
                else {
                    let number = s_array[i].charCodeAt(0) - 96
                    // even numerical value
                    if (number % 2 === 0) cnt2++
                    else cnt3++
                }
            }
            return cnt1 * cnt2 * cnt3
        }
        console.log(productFromString(['a', 'b', 'c']))

        function uniqueValidNumbers(N, inputArray) {
            // sort the array
            const sorted = [...inputArray].sort((a, b) => a -b)

            // console.log(sorted)

            // console.log(inputArray)

            let count = 0

            for(let i = 0; i < N; i++) {
                // check if duplicate
                if(sorted[i] === sorted[i + 1]) {
                    let cur_index = inputArray.indexOf(sorted[i])

                    // mark the current index's value as negative
                    // in the input array
                    // to avoid searching for it again
                    inputArray[cur_index] *= -1

                    let next_index = inputArray.indexOf(sorted[i + 1])
                    // console.log('cur', cur_index, 'next', next_index)
                    // console.log(inputArray)

                    
                    // check if index of next is divisible by index of current
                    if(next_index % cur_index === 0) count++
                } else count++
            }
            return count

        }
        console.log(uniqueValidNumbers(5, [1, 2, 1, 2, 2]))
    </script>
</head>

<body>
    Hello World
</body>

</html>